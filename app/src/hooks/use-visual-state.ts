"use client";

import { createContext, useContext, useCallback, useState, useRef } from "react";
import React from "react";

export interface ViewEntry {
  toolName: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  props: Record<string, any>;
  title: string;
}

export interface DashboardRequest {
  intent: string;
  data?: Record<string, unknown>;
}

export interface RenderRequest {
  component: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  props: Record<string, any>;
}

export type CanvasMode = "idle" | "loading" | "native" | "dashboard" | "error";

/** An action request from a dashboard button/form. */
export interface ActionRequest {
  tool: string;
  params: Record<string, unknown>;
  /** Unique ID for tracking the action lifecycle */
  id: string;
}

export interface ActionResult {
  id: string;
  success: boolean;
  data?: unknown;
  error?: string;
}

interface VisualStateContextType {
  // Legacy view stack (for native component rendering)
  viewStack: ViewEntry[];
  currentView: ViewEntry | null;
  pushView: (view: ViewEntry) => void;
  popView: () => void;
  clearViews: () => void;

  // Dashboard subagent
  dashboardRequest: DashboardRequest | null;
  setDashboard: (req: DashboardRequest) => void;
  clearDashboard: () => void;

  // Direct render from markers
  renderRequest: RenderRequest | null;
  setRender: (req: RenderRequest) => void;

  // Canvas mode
  canvasMode: CanvasMode;
  setCanvasMode: (mode: CanvasMode) => void;

  // Dashboard code (generated by subagent)
  dashboardCode: string | null;
  dashboardCodeType: "tsx" | "html" | null;
  setDashboardCode: (code: string, type: "tsx" | "html") => void;
  clearDashboardCode: () => void;

  // Background update indicator
  isUpdating: boolean;
  setIsUpdating: (v: boolean) => void;

  // Conversation-driven dashboard update (new v2 flow)
  pendingMessages: Array<{ role: string; content: string }> | null;
  pendingAgentData: Record<string, unknown> | null;
  notifyConversationUpdate: (messages: Array<{ role: string; content: string }>, agentData?: Record<string, unknown>) => void;

  // Canvas actions (Phase 4)
  pendingAction: ActionRequest | null;
  lastActionResult: ActionResult | null;
  submitAction: (action: ActionRequest) => void;
  resolveAction: (result: ActionResult) => void;
}

const VisualStateContext = createContext<VisualStateContextType | null>(null);

export function VisualStateProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const [viewStack, setViewStack] = useState<ViewEntry[]>([]);
  const [dashboardRequest, setDashboardRequest] =
    useState<DashboardRequest | null>(null);
  const [renderRequest, setRenderRequest] = useState<RenderRequest | null>(
    null
  );
  const [canvasMode, setCanvasMode] = useState<CanvasMode>("idle");
  const [dashboardCode, setDashboardCodeState] = useState<string | null>(null);
  const [dashboardCodeType, setDashboardCodeType] = useState<
    "tsx" | "html" | null
  >(null);
  const [isUpdating, setIsUpdating] = useState(false);
  const [pendingMessages, setPendingMessages] = useState<
    Array<{ role: string; content: string }> | null
  >(null);
  const [pendingAgentData, setPendingAgentData] = useState<
    Record<string, unknown> | null
  >(null);

  // Phase 4: Canvas actions
  const [pendingAction, setPendingAction] = useState<ActionRequest | null>(null);
  const [lastActionResult, setLastActionResult] = useState<ActionResult | null>(null);

  const submitAction = useCallback((action: ActionRequest) => {
    setPendingAction(action);
    setLastActionResult(null);
  }, []);

  const resolveAction = useCallback((result: ActionResult) => {
    setLastActionResult(result);
    setPendingAction(null);
  }, []);

  const pushView = useCallback((view: ViewEntry) => {
    setViewStack((prev) => [...prev, view]);
    setCanvasMode("native");
    setDashboardRequest(null);
    setRenderRequest(null);
  }, []);

  const popView = useCallback(() => {
    setViewStack((prev) => {
      const next = prev.slice(0, -1);
      if (next.length === 0) {
        setCanvasMode("idle");
      }
      return next;
    });
  }, []);

  const clearViews = useCallback(() => {
    setViewStack([]);
    setCanvasMode("idle");
  }, []);

  const setDashboard = useCallback((req: DashboardRequest) => {
    setDashboardRequest(req);
    setCanvasMode("loading");
    setViewStack([]);
    setRenderRequest(null);
  }, []);

  const clearDashboard = useCallback(() => {
    setDashboardRequest(null);
    setCanvasMode("idle");
  }, []);

  const setRender = useCallback(
    (req: RenderRequest) => {
      setRenderRequest(req);
      // Push as a view entry for the native renderer
      pushView({
        toolName: req.component,
        props: req.props,
        title: req.component.replace(/^render_/, "").replace(/_/g, " "),
      });
    },
    [pushView]
  );

  const setDashboardCode = useCallback(
    (code: string, type: "tsx" | "html") => {
      setDashboardCodeState(code);
      setDashboardCodeType(type);
      setCanvasMode("dashboard");
    },
    []
  );

  const clearDashboardCode = useCallback(() => {
    setDashboardCodeState(null);
    setDashboardCodeType(null);
  }, []);

  const notifyConversationUpdate = useCallback(
    (messages: Array<{ role: string; content: string }>, agentData?: Record<string, unknown>) => {
      setIsUpdating(true);
      setPendingMessages(messages);
      setPendingAgentData(agentData && Object.keys(agentData).length > 0 ? agentData : null);
    },
    []
  );

  const currentView =
    viewStack.length > 0 ? viewStack[viewStack.length - 1] : null;

  return React.createElement(
    VisualStateContext.Provider,
    {
      value: {
        viewStack,
        currentView,
        pushView,
        popView,
        clearViews,
        dashboardRequest,
        setDashboard,
        clearDashboard,
        renderRequest,
        setRender,
        canvasMode,
        setCanvasMode,
        dashboardCode,
        dashboardCodeType,
        setDashboardCode,
        clearDashboardCode,
        isUpdating,
        setIsUpdating,
        pendingMessages,
        pendingAgentData,
        notifyConversationUpdate,
        pendingAction,
        lastActionResult,
        submitAction,
        resolveAction,
      },
    },
    children
  );
}

export function useVisualState() {
  const context = useContext(VisualStateContext);
  if (!context) {
    throw new Error("useVisualState must be used within VisualStateProvider");
  }
  return context;
}
